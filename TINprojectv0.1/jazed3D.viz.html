<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Interplanetary Network — 3D Orbital Visualization</title>
  <style>
    /* Your original CSS here – overlay, buttons, etc. Remains the same for UI consistency */
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    /* ... (paste your full style block from original) ... */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<!-- Your overlay HTML here – title, stats, legend, controls, etc. Remains unchanged -->
<div class="overlay">
  <!-- ... (paste your full overlay div from original) ... -->
</div>

<div class="scanline"></div>
<div class="vignette"></div>
<div class="credit">TIN Architecture v0.1 &mdash; 3D Concept Visualization</div>

<script>
  // Scene setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  camera.position.z = 5;

  // Constants from original
  const AU = 1;
  const earthOrbit = 1 * AU;
  const marsOrbit = 1.52 * AU;
  const earthPeriod = 365.25;
  const marsPeriod = 687;

  let time = 0;
  let playing = true;
  let speedMult = 1;
  const speeds = [1, 2, 5, 10];
  let speedIdx = 0;

  // Add stars (point cloud)
  const starGeometry = new THREE.BufferGeometry();
  const starPositions = [];
  for (let i = 0; i < 300; i++) {
    starPositions.push((Math.random() * 2 - 1) * 10, (Math.random() * 2 - 1) * 10, (Math.random() * 2 - 1) * 10);
  }
  starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starMaterial = new THREE.PointsMaterial({ color: 0xbbbbbb, size: 0.01 });
  const stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);

  // Sun
  const sunGeometry = new THREE.SphereGeometry(0.1, 32, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd60 });
  const sun = new THREE.Mesh(sunGeometry, sunMaterial);
  scene.add(sun);

  // Add glow (billboard sprite or post-processing for better effect)
  const sunGlow = new THREE.PointLight(0xffcc40, 1, 5);
  scene.add(sunGlow);

  // Orbits (lines)
  const earthOrbitLine = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(createEllipsePoints(earthOrbit)), new THREE.LineBasicMaterial({ color: 0x4a90d9, transparent: true, opacity: 0.15 }));
  scene.add(earthOrbitLine);
  const marsOrbitLine = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(createEllipsePoints(marsOrbit)), new THREE.LineBasicMaterial({ color: 0xd9634a, transparent: true, opacity: 0.15 }));
  scene.add(marsOrbitLine);

  function createEllipsePoints(radius) {
    const points = [];
    for (let a = 0; a < Math.PI * 2; a += 0.01) {
      points.push(new THREE.Vector3(Math.cos(a) * radius, Math.sin(a) * radius, 0));
    }
    return points;
  }

  // Bodies (spheres)
  const earth = new THREE.Mesh(new THREE.SphereGeometry(0.05, 32, 32), new THREE.MeshBasicMaterial({ color: 0x4a90d9 }));
  scene.add(earth);
  const mars = new THREE.Mesh(new THREE.SphereGeometry(0.04, 32, 32), new THREE.MeshBasicMaterial({ color: 0xd9634a }));
  scene.add(mars);

  // Relays (small spheres)
  const polars = [];
  for (let i = 0; i < 3; i++) {
    const polar = new THREE.Mesh(new THREE.SphereGeometry(0.02, 16, 16), new THREE.MeshBasicMaterial({ color: 0x40e8c0 }));
    scene.add(polar);
    polars.push(polar);
  }
  const lpoints = [];
  for (let i = 0; i < 3; i++) {
    const lpoint = new THREE.Mesh(new THREE.SphereGeometry(0.02, 16, 16), new THREE.MeshBasicMaterial({ color: 0xc080ff }));
    scene.add(lpoint);
    lpoints.push(lpoint);
  }

  // Links (lines – update dynamically)
  let directLine, relayLines = [], blockedLine;

  function updatePositions() {
    // Earth & Mars
    const earthPos = getEarthPos(time);
    earth.position.set(earthPos.x, earthPos.y, earthPos.z);
    const marsPos = getMarsPos(time);
    mars.position.set(marsPos.x, marsPos.y, marsPos.z);

    // Polars & L-points
    polars.forEach((p, i) => {
      const pos = getPolarRelayPos(time, i);
      p.position.set(pos.x, pos.y, pos.z);
    });
    lpoints.forEach((p, i) => {
      const pos = getLPointPos(time, i);
      p.position.set(pos.x, pos.y, pos.z);
    });

    const conj = checkConjunction(earthPos, marsPos);
    updateUI(earthPos, marsPos, conj);

    // Update lines (remove old, add new)
    if (directLine) scene.remove(directLine);
    relayLines.forEach(l => scene.remove(l));
    if (blockedLine) scene.remove(blockedLine);
    relayLines = [];

    if (conj) {
      // Best relay & lines
      let bestRelay = 0;
      let bestScore = Infinity;
      polars.forEach((pr, i) => {
        const dE = earth.position.distanceTo(pr.position);
        const dM = mars.position.distanceTo(pr.position);
        if (dE + dM < bestScore) { bestScore = dE + dM; bestRelay = i; }
      });

      const relayLine1 = createLine(earth.position, polars[bestRelay].position, 0x40ff90, false);
      scene.add(relayLine1);
      relayLines.push(relayLine1);
      const relayLine2 = createLine(polars[bestRelay].position, mars.position, 0x40ff90, false);
      scene.add(relayLine2);
      relayLines.push(relayLine2);

      blockedLine = createLine(earth.position, mars.position, 0xff4030, true);
      scene.add(blockedLine);
    } else {
      directLine = createLine(earth.position, mars.position, 0x40ff90, false);
      scene.add(directLine);
    }

    // L-point links (dashed)
    lpoints.forEach(lp => {
      const lpLine = createLine(earth.position, lp.position, 0xc080ff, true);
      scene.add(lpLine);
      relayLines.push(lpLine);
    });
  }

  function createLine(start, end, color, dashed) {
    const material = new THREE.LineBasicMaterial({ color, dashSize: dashed ? 0.02 : 0, gapSize: dashed ? 0.02 : 0 });
    if (dashed) material.linewidth = 1; // Dash not perfect in Three.js, but close
    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    return new THREE.Line(geometry, material);
  }

  // Your position getters, dist3d, checkConjunction, updateUI functions – paste unchanged from original

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    if (playing) time += 0.15 * speedMult;
    updatePositions();
    controls.update();
    renderer.render(scene, camera);
  }

  animate();

  // Your button listeners – paste unchanged from original

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>